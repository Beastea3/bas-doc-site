"use strict";(self.webpackChunkbas_doc=self.webpackChunkbas_doc||[]).push([[534],{4692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var o=n(5893),r=n(1151);const a={},s="Leveraging Resolver Contracts",i={id:"tutorials/resolver",title:"Leveraging Resolver Contracts",description:"To enhance the functionality of a Schema, Resolver Contracts serve as pivotal hooks, verifying that attestations adhere to predetermined rules or smart contract logic before finalization. This functionality empowers the infusion of additional smart contract features into your schema, such as implementing an allow-list for attestation creators or enabling NFT minting based on specific conditions.",source:"@site/docs/tutorials/resolver.md",sourceDirName:"tutorials",slug:"/tutorials/resolver",permalink:"/tutorials/resolver",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Referenced Attestation",permalink:"/tutorials/reference_attestation"},next:{title:"Revoking Attestation",permalink:"/tutorials/revoke"}},c={},l=[{value:"Conceptual Framework",id:"conceptual-framework",level:2},{value:"Example Resolver Contracts",id:"example-resolver-contracts",level:2}];function u(e){const t={h1:"h1",h2:"h2",p:"p",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"leveraging-resolver-contracts",children:"Leveraging Resolver Contracts"}),"\n",(0,o.jsx)(t.p,{children:"To enhance the functionality of a Schema, Resolver Contracts serve as pivotal hooks, verifying that attestations adhere to predetermined rules or smart contract logic before finalization. This functionality empowers the infusion of additional smart contract features into your schema, such as implementing an allow-list for attestation creators or enabling NFT minting based on specific conditions."}),"\n",(0,o.jsx)(t.h2,{id:"conceptual-framework",children:"Conceptual Framework"}),"\n",(0,o.jsx)(t.p,{children:"When formulating a new Schema, there arises a need to enforce custom logic or rules specific to the Schema's requirements. Addressing this need involves integrating a resolver contract at the schema level, ensuring strict adherence to the designated smart contract logic."}),"\n",(0,o.jsx)(t.h2,{id:"example-resolver-contracts",children:"Example Resolver Contracts"}),"\n",(0,o.jsx)(t.p,{children:"Coming Soon!"})]})}function d(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>s});var o=n(7294);const r={},a=o.createContext(r);function s(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);